# 动态规划总结

## 背包问题

### 0-1 背包

使用一维数组较容易理解,且占据空间不多，所以使用一维数组

![alt text]({2D6525BB-2688-4135-8549-C95B91159055}.png)
则物品的最大价值是多少

dp[j]表示容量为 j 的背包,所能装的最大价值是 j

dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);这段话含义是

不选物品 i：背包容量 j 不变，价值保持 dp[j]。

选物品 i：背包容量减少 weight[i]，但价值增加 value[i]。

初始化的时候:一般给 dp[0]=0，这段话的含义是背包容量为 0 时所能装的最大价值为 0

遍历顺序:

```cpp
    for(int i=0;i<=物品数量;i++)
    {
        for(int j=weight;j>=weight[i];j--)//背包容量
        {
            dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);
        }
    }
```

倒序遍历背包容量是为了防止重复记录重量,因为每个物品只有一个

#### 询问背包最多能装多少一般使用递推公式 dp[j]=max(dp[j],dp[j-nums[i]]+nums[i])，对应题型如下：

**_416 分割等和子串_**

**_1049 最后一块石头的重量 II_**

#### 问背包装满有几种方法使用递推公式 dp[j]+=dp[j-nums[i]]，题型如下

**_494 目标和_**

**_518 零钱兑换 II_**

**_377 组合总和_**

#### 背包装满的最大价值使用递推公式 dp[j]=max(dp[j]-weight[i]+value[i])

**_474 一和零_**

#### 问装满背包所有物品的最小个数：dp[j] = min(dp[j - weight[i]] + 1, dp[j]);

**_322 零钱兑换_**

**_279 完全平方数_**

### 完全背包

**_完全背包在形式上几乎和 0-1 背包一样,只有在遍历的时候有区别_**

完全背包在遍历背包容量时使用的是正序遍历,因为在完全背包的题型下,每个物品被视为无限多

先遍历物品后遍历背包容量，还是先遍历背包容量再遍历物品，在排列题和组合题的用法不一样

```cpp
// 组合数：外层遍历物品，内层遍历背包
int combinationSum(vector<int>& nums, int target)
{
vector<int> dp(target + 1, 0);
dp[0] = 1; // 初始化：总和为 0 的组合有 1 种（不选任何物品）

    for (int i = 0; i < nums.size(); i++)
    {      // 遍历物品
        for (int j = nums[i]; j <= target; j++)
        { // 遍历背包
            dp[j] += dp[j - nums[i]];
        }
    }

    return dp[target];

}

// 排列数：外层遍历背包，内层遍历物品
int permutationSum(vector<int>& nums, int target)
{
vector<int> dp(target + 1, 0);
dp[0] = 1; // 初始化：总和为 0 的排列有 1 种（不选任何物品）

    for (int i = 1; i <= target; i++)
    {          // 遍历背包
        for (int j = 0; j < nums.size(); j++)
        {  // 遍历物品
            if (i >= nums[j])
            {
                dp[i] += dp[i - nums[j]];
            }
        }
    }

    return dp[target];

}
```

比如[1,2],[2,1]在组合时会被认为是一个组合

排列则会将这两个当做不一样排列形式

组合题:**_518 零钱兑换 II_**

排列题:**_377 组合总和 IV_**

## 买卖股票问题

买卖股票问题通常使用二维数组来解决

dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); // 第一次持有股票
dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); // 第一次卖出股票
dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); // 第二次持有股票
dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]); // 第二次卖出股票

使用这种形式来表示买卖股票的状态,通常是买入和卖出两种状态

## 子序列

### 不连续子序列

当题目不为连续序列时使用 dp[i] = max(dp[i], dp[j] + 1);或 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);进行递推

因为子序列不要求连续,当字符不匹配时，需从两个可能的子问题中选择更优的解

**_300 最长上升子序列_**

**_1143 最长公共子序列_**

**_1035 不相交的线_**

### 连续子序列

当题目为连续序列时使用 dp[i] = dp[i - 1] + 1;进行递推

子序列要求连续，所以只能在上一次序列长度后+1 来表示序列增加

**_674 最长连续递增序列_**

**_718 最长重复子数组_**

### 编辑距离

**情况 1：**A[i-1] == B[j-1]（当前字符匹配）

无需操作，直接继承前一个状态：

dp[i][j] = dp[i-1][j-1]

**情况 2：**A[i-1] != B[j-1]（当前字符不匹配）

**1.删除 A[i-1]:**

dp[i-1][j]+1:表示忽略 A 的当前字符 A[i-1]，直接处理 A 的前 i-1 个字符与 B 的前 j 个字符的匹配,+1 表示操作次数

**2.增加 A[j-1]**

dp[i][j-1]+1:表示忽略 B 的当前字符 B[j-1]，先处理 A 的前 i 个字符与 B 的前 j-1 个字符的匹配，相当于给 A 增加,+1 表示操作次数

**3.替换**

当 dp[i][j] = dp[i-1][j-1]时相同，如果要进行一次替换操作让着两个相同，则需要在后面+1

dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;

因为需要最少的操作数,所以使用 min

**_72 编辑距离_**

## 回文

### 回文子串

在判断是不是回文子串时,使用双指针从头和尾开始遍历
如果遇到两个元素相同时,判断两个元素相隔的距离
如果小于等于 1 说明两元素相邻,是回文子串
如果大于 1 判断 i 和 j 区间的元素是否相同

### 最长回文子串

写这道题时需要使用一个二维 bool 数组来表示是否为回文串
判断是否为回文串时,首先对所有单个子串初始化为 true

然后再判断两个字符是否为回文 dp[i]==dp[i+1],这是为了更新起始位置与最大长度，方便后续计算

如果是三个以上的，则需要对计数位置进行计算使用 j=i+len-1 进行计算，如果两元素相同且区间元素也相同，则对回文计数器+1
